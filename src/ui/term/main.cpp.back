#include <algorithm>
#include <chrono>
#include <cstdlib>
#include <cstdio>
#include <experimental/optional>
#include <memory>
#include <thread>

#include "mpe/block.hpp"
#include "mpe/field.hpp"
#include "mpe/randomizer/bag.hpp"
#include "mpe/wallkick/srs.hpp"

#include "keyboard.hpp"
#include "renderer.hpp"

using namespace std;

enum {
    KLeft, KRight, KDown, KZ, KX, KSpace, KQ, KC
};

static constexpr int DAS = 8;

struct KeyMap {
    int key;
    int index;
};

static constexpr KeyMap keymaps[8] = {
    { KEY_LEFT, KLeft }, { KEY_RIGHT, KRight },
    { KEY_DOWN, KDown }, { KEY_Z, KZ },
    { KEY_X, KX }, { KEY_SPACE, KSpace },
    { KEY_Q, KQ }, { KEY_C, KC }
};

class Engine
{
  public:
    Engine() : m_block(0), m_running(true)
    {
        m_field = mpe::Field();
        m_bag = make_unique<mpe::randomizer::Bag>();
        m_wk = make_unique<mpe::wallkick::SRS>();
        m_block = m_bag->next();
    }

    void updateKeys()
    {
        m_keyboard.readEvents();
        for (auto keymap : keymaps) {
            if (m_keyboard.isSet(keymap.key))
                m_keystate[keymap.index]++;
            else
                m_keystate[keymap.index] = 0;
        }
    }

    void update()
    {
        /* Horizontal movement */
        if (m_keystate[KLeft] == 1 || m_keystate[KLeft] > DAS)
            m_block.moveLeft(m_field);
        else if (m_keystate[KRight] == 1 || m_keystate[KRight] > DAS)
            m_block.moveRight(m_field);

        /* Vertical movement */
        if (m_keystate[KDown] == 1 || m_keystate[KDown] > DAS)
            m_block.moveDown(m_field);

        /* Rotation */
        if (m_keystate[KZ] == 1)
            m_block.rotateLeft(m_field, *m_wk);
        if (m_keystate[KX] == 1)
            m_block.rotateRight(m_field, *m_wk);

        /* Hold piece */
        if (m_keystate[KC] == 1 && m_block.m_can_be_held) {
            if (!m_hold) {
                m_hold = mpe::Block(m_block.m_id, 0);
                m_block = m_bag->next();
            }
            else {
                swap(m_hold.value(), m_block);
            }
            m_block.m_can_be_held = false;
        }

        /* Hard drop */
        if (m_keystate[KSpace] == 1) {
            m_block.hardDrop(m_field);
            m_field.placeBlock(m_block);
            m_field.lineClear();
            m_block = m_bag->next();
        }

        if (m_keystate[KQ] == 1) {
            m_running = false;
        }
    }

    void render() const
    {
        std::cout << tr::clearScreen;
        std::cout << tr::resetColor;
        renderField();
        renderPreview();
        renderHold();
        std::cout.flush();
    }

    bool isRunning()
    {
        return m_running;
    }

  private:
    void renderBlock(mpe::Block &block) const
    {
        std::cout << tr::saveCursor;
        std::cout << tr::setColor(block.m_id);

        for (int i = 0; i < 4; ++i) {
            std::cout << tr::restoreCursor;

            const int x = 1 + 2 * block.m_data[i].x;
            const int y = 1 + block.m_data[i].y;

            std::cout << tr::moveRelative(x, y);
            std::cout << tr::squareFill;
        }

        std::cout << tr::resetColor;
        std::cout << tr::restoreCursor;
    }

    void renderHold() const
    {
        if (!m_hold)
            return;

        mpe::Block hold(m_hold.value().m_id);
        std::cout << tr::homePosition;
        renderBlock(hold);
    }

    void renderPreview() const
    {
        if (m_bag->previewCount() == 0)
            return;

        auto pieces = m_bag->previewPieces();

        for (int i = 0; i < std::min(m_bag->previewCount(), 4); ++i) {
            std::cout << tr::homePosition;
            std::cout << tr::moveRelative(32, i * 5);
            mpe::Block preview(pieces[i]);
            renderBlock(preview);
        }
    }

    void renderField() const
    {
        /* Draw preview pieces and give a position to draw hold */
        mpe::Block ghost(m_block);
        ghost.hardDrop(m_field);

        std::cout << tr::homePosition;

        for (int y = m_field.getHeight() - 1; y >= 0; --y) {
            std::cout << "          ";
            std::cout << tr::verticalBorder;
            for (int x = 0; x < m_field.getWidth(); ++x) {
                if (m_field.getCell(x, y)) {
                    std::cout << tr::setColor(m_field.getCell(x, y) - 1);
                    std::cout << tr::squareFill;
                    std::cout << tr::resetColor;
                }
                else if (m_block.isSet(x, y)) {
                    std::cout << tr::setColor(m_block.m_id);
                    std::cout << tr::squareFill;
                    std::cout << tr::resetColor;
                }
                else if (ghost.isSet(x, y)) {
                    std::cout << tr::setColor(m_block.m_id);
                    std::cout << tr::squareLine;
                    std::cout << tr::resetColor;
                }
                else {
                    std::cout << tr::squareEmpty;
                }
            }

            std::cout << tr::verticalBorder;
            std::cout << tr::nextLine;
        }

        std::cout << "          ";
        std::cout << tr::upAndLeftBorder;
        for (int x = 0; x < m_field.getWidth(); ++x) {
            std::cout << tr::horizontalBorder;
        }

        std::cout << tr::upAndRightBorder;
    }

    array<int, 8> m_keystate;
    unique_ptr<mpe::randomizer::Randomizer> m_bag;
    unique_ptr<mpe::wallkick::Wallkick> m_wk;
    mpe::Block m_block;
    experimental::optional<mpe::Block> m_hold;
    mpe::Field m_field;
    Keyboard m_keyboard;
    bool m_running;
};

using namespace std::literals::chrono_literals;

int main(void)
{
    Engine engine;

    std::cout << tr::hideCursor;
    std::cout << tr::saveScreenAndClear;

    while (engine.isRunning()) {
        auto next_time_point = std::chrono::steady_clock::now() + 16ms;

        engine.updateKeys();
        engine.update();
        engine.render();

        std::this_thread::sleep_until(next_time_point);
    }

    std::cout << tr::viewCursor;
    std::cout << tr::restoreScreen;

    return 0;
}
